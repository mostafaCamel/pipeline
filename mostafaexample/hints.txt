https://github.com/tektoncd/pipeline/issues/1744
closed https://github.com/tektoncd/pipeline/pull/5358 
closed https://github.com/tektoncd/community/pull/868

this is alreay supported within steps (only as an env , not for variable substituion) . (See docs/variables.md) We want it within Task as well
PR was closed for unrelated reasosn. You can cherry-pick it then build upon it

https://github.com/tektoncd/pipeline/blob/main/docs/developers/feature-versioning.md
https://github.com/tektoncd/pipeline/blob/main/api_compatibility_policy.md#approving-api-changes
[v1beta1] are deprecated. New features will not be added, but they will receive bug fixes.
v1beta1.Task is a deprecated CRD but I rpobably need to create a new feature flag and have it as a beta fearute in the stable CRD (v1)


make changes in the go packages then run the bash script hack/update-codegen.sh which will update the openapi_generated.go and swagger.json files for you
pipeline-api.md is also generated automatically
tasks.md is written manually
/opt/homebrew/bin/bash hack/update-codegen.sh 

update-schema does nto detect small bool additions to the api, so add a dummy field (like StepsB []StepState),
run the script which will add the 2 fields to the CRD then remove the dummy field then run the script again (which will remove the dummy field from the crd). Probably controller-gen is triggered by changes in zz_generated.deepcopy.go

if valueFrom is set, taskRun/taskSpec cannot set a value ... failure at application of taskrun
If valueFrom is set, we can still have a default


The value has to be resolved during taskrun (not task) so that every newly spun task (pod) gets the updated value
Is it worth it to mirror the behavior of COnfoigMap/Pod in k8s so that the TaskRun obtains the updated value if the COnfigMap is updated after the initialization of the TaskRun?

taskrun_validation param_conversion
applyStepActionParameters

error of non-existent configMap in task/task spec versus task run ?

optional param? no error if configmap does not contain it?

taskRef or taskSpec - Specifies the Tasks that the TaskRun will execute. taskSpec is the task-equivalent of anonymous functions

overridable by taskRun?

Example of a feature flag	// PipelineSpec is a specification of a pipeline
	// Note: PipelineSpec is in preview mode and not yet supported
	// Specifying PipelineSpec can be disabled by setting
	// `disable-inline-spec` feature flag..

ValidatePipelineTasks (both the implementation and the call) in pipeline_validation.go has a code-lilke validation if not exactly one of taskRef and taskSpec is defined
We should have something similar for COnfigMapKeyRef and (eventually) SecretMapKeyRef in param_validation.go for validation of ParamFromSource (valueFrom)
func (pt PipelineTask) Validate(ctx context.Context)

for task_validation and pipeline_validation:
- valueFrom fails if it exists and the flag is not active
- valueFrom has  either COnfigMappKeyRef (or eventuallySecretKeyRef)
 ... run manually to ensure name and key only and thir attirbute will fail normally


During pipelinerun and taskrun initialization (check where param assignment is validated):
- fail if configMap does not exist
- fail if variable does not exist in configMap
- fail if PipelineRun (or respectively TaskRun) has this value defined
- assign the value from the configMap to the parameter


export KO_DOCKER_REPO='docker.io/mostafaabdelwahab'


No need to guard behind feature flag in pipelinerun validation or initialization


value and ValueFrom in Param
From a user api perspective, if the feature flag is enabled then exactly one or the other needs to be passed in the json
If the feature flag is disabled, then only value can be passed to the json

From a struct perspective, valueFrom will be similar to how it is described here  https://github.com/tektoncd/community/pull/868/files
We will add a new bool fetchFromSource (default false) to the ParamValue struct
If fetchFromSource is true then the ValueType must be StringVal .... in the future, we can add support for file-like keys in the ConfigMap <-> ParamTypeObject in ParamValue in Tekton
You don't need to play with Marshall

You set volumes at the Pod level, then mount them into containers inside that Pod

https://stackoverflow.com/questions/59964619/difference-using-pointer-in-struct-fields

func ApplyParameters apply.go -> ApplyReplacements
logger := logging.FromContext(ctx)
logger.Errorf("Failed dryRunValidation for PipelineRun %s: %w", pr.Name, err)

roundtrip patching (unmarshal then marshal) then validation then applyparamaters then each of validation and applyparameters get called multiple times until piepline completion (validation in webhook and applyparameters in controller)
the first validation occurs then the first apply occurs

Roundtrip patching occurs in webhook
When pipelinerun is created but fails with"CouldntGetPipeline" , webhook has 3 validation calls. Controller does not have any applyparameters call

The reconciler is called in the controller

omitzero (which requires go 1.24+) in Param.Value then a validation that either value or ValueFrom are defined can fix the issue
Error from server (BadRequest): error when creating "mostafaexample/hello-goodbye-pipeline-run.yaml": admission webhook "webhook.pipeline.tekton.dev" denied the request: mutation failed: cannot create patch for round tripped newBytes: cannot marshal interface: json: error calling MarshalJSON for type v1.ParamValue: impossible ParamValues.Type: ""

ftech the value from source before the ApplyParamters methods (specifically ApplyParametersToWorkspaceBindings) calls in the reconcile method in pipelinerun.go and taskrun.go
Actually it is needed before ValidateParamTypesMatching

c.Env[ie].ValueFrom.SecretKeyRef.LocalObjectReference.Name
and
c.Env[ie].ValueFrom.ConfigMapKeyRef.Key = substitution.ApplyReplacements(e.ValueFrom.ConfigMapKeyRef.Key, stringReplacements)


"Failed to create pod due to config error" when using valueFrom in env in step with inexistent configmap
The repo kubernetes/pkg/kubelet/kubelet_pods.go in the kubernetes project  -> func (kl *Kubelet) makeEnvironmentVariables
It sets the environment variable for the container (corresponding to the steprun in tekton) based on the configmaps available in the pod's (corresponding to tekton taskrun) namespace
https://github.com/kubernetes/kubernetes/blob/58704903c5f3616967ea9e71cb173d7a44868aa3/pkg/kubelet/kubelet_pods.go#L847
There is no standalone api methods on COnfigMapKeySelector in k8s.io

ConfigMapKeySelector is only applied at runtime : The tekton step creates a corev1.container and passes the the env to it
https://kubernetes.io/blog/2021/08/06/server-side-apply-ga/
Server-side Apply helps users and controllers manage their resources through declarative configurations. Server-side Apply replaces the client side apply feature implemented by “kubectl apply” with a server-side implementation, permitting use by tools/clients other than kubectl
Each Apply function (from the client) takes an "applyconfiguration" type


https://tekton.dev/docs/pipelines/variables/
No substitution needed in PipelineRun.spec.params or TaskRun.spec.params so I don't think we should support substitution in (PipelineRun|TaskRun).spec.params[*].valueFrom
TriggerTemplates have support for TriggerTemplace.resourcetemplates[*].spec.params[*] but TriggerTemplates are deprecated (available in v1beta1 but not v1)


Given that all TaskRuns of the PipelineRun will be in the same namespace, no need to have access to check for the configmaps outside this namespace
`k8s.CoreV1().ConfigMaps(pipelineRun.Namespace)` should be enough
https://tekton.dev/docs/pipelines/tasks/#task-vs-clustertask
ClusterTasks are deprecated so no need to add specific support for them (i.e. no expectation that the COnfigMap can be in a namespace other than pipelinerun's namespace)


Question: even after the PipelineRun completion, describe pipelinerun does not show the value/valueFrom switch. Is that ok or should I run PipelineRunTerface.Update() in ReconcileKind after the first param source resolution?
Example: updateLabelsAndAnnotations


UpdateStatus is run automatically

ResolvedPipelineTask contains a PipelineTask and its associated TaskRun(s) or CustomRuns, if they exist.


https://medium.com/@gallettilance/10-things-you-should-know-before-writing-a-kubernetes-controller-83de8f86d659
https://github.com/kubernetes-sigs/controller-runtime/blob/main/pkg/client/fake/client.go#L912 for patchactionimpl (func dryPatch)
https://github.com/kubernetes/client-go/issues/1385 https://github.com/stippi2/kubernetes-replicator/blob/3950d938fe84f13486a38414e0aa83fd8172c131/replicate/secret/secrets_test.go#L99-L168


https://github.com/tektoncd/pipeline/issues/6214 PipelineTasksAggregateStatus


~he webhook’s entrypoint is in cmd/webhook/main.go, which uses Knative’s configmapwatcher to load and monitor ConfigMaps like config-defaults and feature-flags. Those config maps get passed into the webhook’s context upon startup.

In github.com/tektoncd/pipeline, the pkg/resolution package provides a plug-in framework for resolving Tekton resources (like Task, Pipeline, PipelineRun) from remote sources—such as Git repositories, OCI bundles, the Tekton Hub, or other clusters.

func (prs *PipelineRunSpec) SetDefaults(ctx context.Context)


The mutating webhook is the defaulting webhook https://vincenthou.medium.com/how-to-use-mutating-webhook-for-the-operator-with-operator-sdk-f940bd98e10b
mutatingwebhook

"oldObj.SetDefaults(ctx)" in mutate in defaulting.... so we can modify the PipelineRunSpec.SetDefaults in pipelinerun_defaults.go
Keep in mind that SetDefaults is also called by the reconciler
Pseudo-code to have the resolution only one time (caveat: annotations can be changed by user but I think this is a small risk):
if pipelineRunSpec does not have annotation "attemptToResolveAlreadyRan"
     for each param.{value,valueSource} in pipelineRunSpec:
	    if value and not valueSource:
		    do nothing // this is the most common behavior (users not using this new feature)
	    if not value and not valueSource:
		    do nothing // the validation webhook (not the mutaing webhook) will fail later during the usual param validation
		if value and valueSource:
		    error // user passed both value and valueSource
		if valueSource and not value:
		    do the resolution // TODO: verify that you can actually read custom configmaps here
	add the annotation "attemptToResolveAlreadyRan" to pipelineRunSpec

in cmd/webhook/main.go, the webhook is limited to the tekton-pipelines-webhook namepspace
ctx := injection.WithNamespaceScope(signals.NewContext(), system.Namespace())

https://github.com/tektoncd/pipeline/pull/8642
https://github.com/tektoncd/pipeline/blob/main/DEVELOPMENT.md
export KO_DOCKER_REPO='docker.io/mostafaabdelwahab' #make sure docker desktop is running and you are logged in
kind create cluster #create a local cluster using kind
cd ${BASE_REPO}
ko delete -R -f config/ ;  ko apply -R -f config/  # this builds the pipeline CRD with my local changes and pushes the changes to my dockerhub regsitry. Can take 5-10 minutes (pushing to dockerhub is netowrk-limited and time-consuming)
kubectl get pods -n tekton-pipelines # Confirm it is running


For logs (use --tail or -f to stream)
kubectl -n tekton-pipelines logs $(kubectl -n tekton-pipelines get pods -l app=tekton-pipelines-webhook -o name)
kubectl -n tekton-pipelines logs $(kubectl -n tekton-pipelines get pods -l app=tekton-pipelines-controller -o name)
 

Then cleanup your lcoal changes with ko delete -R -f config/

cat <<EOF | kubectl apply -f -
apiVersion: v1
kind: ConfigMap
metadata:
  name: myhardcodedconfigmapname
data:
  myhardcodedkey: "xyz"
---
apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: hello
spec:
  params:
  - name: username
    type: string
  steps:
    - name: echo
      image: alpine
      script: |
        #!/bin/sh
        echo \$(params.username)
---
apiVersion: tekton.dev/v1
kind: TaskRun
metadata:
  name: hello-run
spec:
  taskRef:
    name: hello
  params:
  - name: username
    value: "abc"
EOF